\documentclass[11pt,doublespace]{article} 
\topmargin=-0.5in 
\oddsidemargin=0in 
\textheight=9in 
\textwidth=6.5in 
\newcommand{\pderiv}[2]{\ensuremath{\frac{\partial #1 }{\partial #2}}}
\usepackage{latexsym}
%\pagestyle{empty}
\usepackage{graphicx}
\usepackage{color}

\begin{document}

\begin{center}
{\large {\bf Startup\\
Outline}}
\end{center}

\bigskip
{\LARGE Sequence of procedures for starting or restarting CHIMERA3D} \\

Program {\bf radhyd\_MPI} is the top level program that initiates and executes CHIMERA3D.

\begin{itemize}
   
  \item The following sequence reads in the array dimensions, the data paths (where to find the restart files and where to send the output data), the header, the parameter `nrst' (the cycle number from which to start or restart the run, the parameter `nouttmp' which specifies the mode of the restart, and the model dimensions (imin  - minimum radial zone, imax - maximum radial zone,  jmin - minimum angular zone, jmax - maximum angular zone, kmin - minimum azimuthal zone, kmax - maximum azimuthal zone)\\


  \textcolor{blue}{ {\bf radhyd\_MPI} }


\begin{enumerate}
 
  \item  \textcolor{blue}{ {\bf MPI\_INIT} }
  [Computes the total neutrino energy density and energy flux, needed to compute PN gravity.]
    
  \item  \textcolor{blue}{ {\bf MPI\_COMM\_RANK} }
  [Computes the angular average of density, matter pressure, matter energy, radial velocity, angular velocity, velocity squared, neutrino energy density, and neutrino flux.]

  \item  \textcolor{blue}{ {\bf MPI\_COMM\_SIZE} }
  [Using the initial grid, computes the gravitational potential and forces.]\\

{\color{red}

  The following is performed on processor 0 only.
  
  \item \textcolor{blue}{ {\bf read\_pack\_array\_dimensions} }
  [Controls the input of the array dimensions, data paths, and the number of active radial, angular, and azimuthal zones as given by the restart model.]
  
  \item Opens Data3/Initial\_Data/array\_dimensions.d \\
  \textcolor{blue}{ {\bf read\_array\_dimensions} }
  [Reads in the array dimensions and data paths from file array\_dimensions.d in directory Data3/Initial\_Data.] \\
  Closes Data3/Initial\_Data/array\_dimensions.d
   
  \item Opens Data3/Initial\_Data/reset.d \\
  \textcolor{blue}{ {\bf read\_pack\_init} }
  [From file reset,d in directory Data3/Initial\_Data reads the problem header, the parameter nrst, which, if nouttmp /= 1 or 2, tells which cycle number to pick up the restart, and the parameter nouttmp.] \\
  Closes Data3/Initial\_Data/reset.d
  
  \item The following directs the input of the problem dimensions, imin, imax, jmin, jmax, kmin, kmax. This depends on the values of nrst and nouttmp \\
  nrst:
  
\begin{enumerate}

  \item nrst = 0
  [New problem is initiated.]
  
\begin{enumerate}
  
  \item Opens Data3/Initial\_Data/radhyd\_keys.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (radial, angular, and azimuthal dimensions) of the problem.] \\
  Closes Data3/Initial\_Data/radhyd\_keys.d
  
\end{enumerate}

  \item nrst $>$ 0
  [Problem is being restarted]\\
  
 \item  ny = nz = 1 (1-D problem):
 
  \item Opens Data3/Initial\_Data/radhyd\_keys.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (imin, imax, jmin, jmax, kmin, kmax).] \\
  Closes Data3/Initial\_Data/radhyd\_keys.d
  
  \item ny $>$ 0 and/or nz $>$ 0 (Multi-D problem)
  
\begin{enumerate}

  \item nouttmp = 1
  [Problem is being restarted from temporary restart files "1"]
  
\begin{enumerate}
  
  \item Opens Data\_Path/Restart/rst\_tmp1\_keys.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (imin, imax, jmin, jmax, kmin, kmax).] \\
  Closes Data\_Path/Restart/rst\_tmp1\_keys.d

\end{enumerate}

  \item nouttmp = 2
  [Problem is being restarted from temporary restart files "2"]
  
\begin{enumerate}
  
  \item Opens Data\_Path/Restart/rst\_tmp2\_keys.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (imin, imax, jmin, jmax, kmin, kmax).] \\
  Closes Data\_Path/Restart/rst\_tmp2\_keys.d

\end{enumerate}

  \item nouttmp = 3
  [Problem is being restarted from permanent restart files "XXXXXXX"]
  
\begin{enumerate}
  
  \item Opens Data\_Path/Restart/restart\_keysXXXXXXX.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (imin, imax, jmin, jmax, kmin, kmax).] \\
  Closes Data\_Path/Restart/restart\_keysXXXXXXX.d

\end{enumerate}

  \item nouttmp = 4
  [Problem is being restarted from "final" restart files]
  
\begin{enumerate}
  
  \item Opens Data\_Path/Restart/restart\_final\_keys.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (imin, imax, jmin, jmax, kmin, kmax).] \\
  Closes Data\_Path/Restart/restart\_final\_keys.d

\end{enumerate}

  \item nouttmp = 5
  [Multii-D problem is being restarted from a 1-D problem]
  
\begin{enumerate}
  
  \item Opens Data\_Path/Restart/restart\_keysXXXXXXX.d \\
  \textcolor{blue}{ {\bf read\_model\_dimensions} }
  [Reads in the model dimensions (imin, imax, jmin, jmax, kmin, kmax).] \\
  Closes Data\_Path/Restart/restart\_keysXXXXXXX.d

\end{enumerate}

\end{enumerate}

\end{enumerate}

  \item Checks that the number of processors requested (n\_dim\_data(7) = n\_proc) is equal to the number of processors (num\_procs) allocated to the run.\\

  }
  
  The following is performed on all processors.
  
  \item Broadcast data paths and array dimensions to all processors.
  
  \item \textcolor{blue}{ {\bf unpack\_array\_dimenisons} }
  [Unpacks the array dimensions and domain decomposition on each processor.]
  
  \item Assign the log file names for the directory Data\_Path/Log\_File
  
  \item  \textcolor{blue}{ {\bf load\_array\_module} }
  [Store the array dimensions, domain decomposition and number of processors in the array module.]
  
  \item Create communicators for the j and k domain decompositions
  
  \item Check that the number of processors assigned to the y and z decompositions is the number requested, and the n\_proc\_y * n\_proc\_z, n\_proc.\\
  
 The following continues the startup sequence. 
  
  \item \textcolor{blue}{ {\bf initialize} }
  
\begin{enumerate}

  \item \textcolor{blue}{ {\bf dimension\_arrays} }
  [Dimensions the arrays in all the modules and zeros or assigns default values to all the variables.]
  
\begin{enumerate}

  \item  \textcolor{blue}{ {\bf dimension\_mgfld\_arrays} }
  
\begin{enumerate}

  \item \textcolor{blue}{ {\bf dimension\_abem\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf abem\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_abem\_y\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf abem\_y\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_abem\_z\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf abem\_z\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_brem\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf brem\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_incrmnt\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf incrmnt\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_mdl\_cnfg\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf mdl\_cnfg\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_mdl\_cnfg\_y\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf  mdl\_cnfg\_y\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_mdl\_cnfg\_z\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf mdl\_cnfg\_z\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_nu\_dist\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf nu\_dist\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_nu\_energy\_grid\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf nu\_energy\_grid\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_pair\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf pair\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_scat\_a\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf scat\_a\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_scat\_e\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf scat\_e\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_scat\_i\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf scat\_i\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_scat\_n\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf scat\_n\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_scat\_nA\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf scat\_nA\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_scat\_nn\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf scat\_nn\_module}.]

\end{enumerate}

  \item  \textcolor{blue}{ {\bf dimension\_edit\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf edit\_module}.]
  
  \item  \textcolor{blue}{ {\bf dimension\_eos\_arrays} }

\begin{enumerate}

  \item \textcolor{blue}{ {\bf dimension\_eos\_snc\_x\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf eos\_snc\_x\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_eos\_snc\_y\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf eos\_snc\_y\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_eos\_snc\_z\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf eos\_snc\_z\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_eos\_bck\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf eos\_bck\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_eos\_ls\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf eos\_ls\_module}.]

  \item \textcolor{blue}{ {\bf dimension\_eos\_drv\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays in {\bf eos\_drv\_module}.]

\end{enumerate}

  \item  \textcolor{blue}{ {\bf dimension\_nucbrn\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays {\bf innucbrn\_module}.]

  \item  \textcolor{blue}{ {\bf dimension\_e\_advct\_arrays} }
  [Dimensions the arrays and initializes the variables and arrays {\bf e\_advct\_module}.]

\end{enumerate}
  
  \item \textcolor{blue}{ {\bf initialize\_variables} }
  [Initializes (assigns default values) to variables in modules not containing allocatable arrays, and therefore not initialized in the {\bf dimension\_array call} ]
  
\begin{enumerate}

  \item \textcolor{blue}{ {\bf initialize\_global\_var} }
  [Initialize the global hydro variables in module {\bf evh1\_global}.]

  \item \textcolor{blue}{ {\bf initialize\_cycle\_arrays} }
  [Initialize the variables in {\bf cycle\_module}.]

  \item \textcolor{blue}{ {\bf initialize\_it\_tol\_arrays} }
  [Initialize the variables in {\bf it\_tol\_module}.]

  \item \textcolor{blue}{ {\bf initialize\_bomb\_arrays} }
  [Initialize the variables in {\bf bomb\_module}.]

  \item \textcolor{blue}{ {\bf initialize\_rezone\_arrays} }
  [Initialize the variables in {\bf rezone\_module}.]\\

\end{enumerate}

{\color{red}

  The following is performed on processor 0 only.\\

  \item \textcolor{blue}{ {\bf problem\_read} }
  [Orchestrate the reading in of the initial or restart model and problem keys.]\\
  
  Zero all data buffers\\
  
  Assign values to `nread' and `nprint'\\
  
  Open {\bf Data3/Initial\_Data/reset.d} for reading in `nrst' and `nouttmp'
  
  Open {\bf Data\_Path/Run\_Log/superdump.d} for echoing the read in of problem keys, and for outputting cycle number.
  
\begin{enumerate}

  \item \textcolor{blue}{ {\bf problem\_pack} }
  [Directs the reading in of the problem keys and, if the problem is being initiated or if it is 1D and being restarted, the model configuration.]\\ \\
  
  {\bf The following is performed if nrst = 0 (problem is being initiated)} \\

\begin{enumerate}

  \item \textcolor{blue}{ {\bf radhyd\_read} }
  [Directs the reading and packing of the keys in {\bf radhyd\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/radhyd\_keys.d}\\
  Call \textcolor{blue}{ {\bf read\_pack\_radhyd\_keys} } to read and pack the keys  in {radhyd\_keys.d}.\\
  Close {\bf Data3/Initial\_Data/radhyd\_keys.d}

  \item \textcolor{blue}{ {\bf eos\_read} }
  [Directs the reading and packing of the keys in {\bf eos\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/eos\_keys.d}\\
  Call \textcolor{blue}{ {\bf read\_pack\_radhyd\_keys} } to read and pack the keys  in {\bf radhyd\_keys.d}.\\
  Close {\bf Data3/Initial\_Data/radhyd\_keys.d}

  \item \textcolor{blue}{ {\bf transport\_read} }
  [Directs the reading and packing of the keys in {\bf transport\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/transport\_keys.d}\\
  Call \textcolor{blue}{ {\bf read\_pack\_transport\_keys} } to read and pack the keys  in {\bf transport\_keys.d}.
  Close {\bf Data3/Initial\_Data/transport\_keys.d}

  \item \textcolor{blue}{ {\bf e\_advct\_read} }
  [Directs the reading and packing of the keys in {\bf e\_advct\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/e\_advct\_keys.d}\\
  Call \textcolor{blue}{ {\bf read\_pack\_e\_advct\_keys} } to read and pack the keys  in {\bf e\_advct\_keys.d}.
  Close {\bf Data3/Initial\_Data/transport\_keys.d}

  \item \textcolor{blue}{ {\bf edit\_read} }
  [Directs the reading and packing of the keys in {\bf edit\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/edit\_keys.d}\\
  Call \textcolor{blue}{ {\bf read\_pack\_edit\_keys} } to read and pack the keys  in {\bf edit\_keys.d}.\\
  Close {\bf Data3/Initial\_Data/edit\_keys.d}

  \item \textcolor{blue}{ {\bf hydro\_read} }
  [Directs the reading and packing of the keys in {\bf hydro\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/hydro\_keys.d}\\
  Call \textcolor{blue}{ {\bf read\_pack hydro\_keys} } to read and pack the keys  in {\bf hydro\_keys.d}.\\
  Close {\bf Data3/Initial\_Data/hydro\_keys.d}

  \item \textcolor{blue}{ {\bf nuclear\_read} }
  [Directs the reading and packing of the keys in {\bf nuclear\_keys.d}.]\\
  Open {\bf Data3/Initial\_Data/nuclear\_keys.d}.\\
  Call \textcolor{blue}{ {\bf read\_pack nuclear\_keys} } to read and pack the keys  in {\bf nuclear\_keys.d}.\\
  Close {\bf Data3/Initial\_Data/nuclear\_keys.d}

  \item \textcolor{blue}{ {\bf model\_read} }
  [Directs the reading and packing of the model configuration in {\bf initial\_model.d}.]\\
  Open {\bf Data3/model\_Data/initial\_model.d}.\\
  Call \textcolor{blue}{ {\bf read\_pack\_initial\_model} } to read and pack the keys  in {\bf initial\_model.d}.\\
  Close {\bf Data3/model\_Data/initial\_model.d}\\ \\

  {\bf The following is performed if nrst $>$ 0 (problem is being restarted)} \\
  
  The following file is opened in order to read in the problem keys.\\
  
  nouttmp = 1: Open {\bf Data\_Path/Restart/rst\_tmp1\_keys.d}
    
  nouttmp = 2: Open {\bf Data\_Path/Restart/rst\_tmp2\_keys.d}
    
  nouttmp = 3: Open {\bf Data\_Path/Restart/restart\_keysXXXXXXX.d}
    
  nouttmp = 4: Open {\bf Data\_Path//Restart/restart\_final\_keys.d}
    
  nouttmp = 5: Open {\bf Data\_Path/Restart/restart\_keysXXXXXXX.d}\\
  
  From the above opened file, the following read commands are performed.\\
  
  \item \textcolor{blue}{ {\bf read\_pack\_radhyd\_keys} }
  [Read and pack the radhyd keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_eos\_keys} }
  [Read and pack the eos keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_transport\_keys} }
  [Read and pack the eos keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_eos\_keys} }
  [Read and pack the transport keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_e\_advect\_keys} }
  [Read and pack the e\_advect keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_edit\_keys} }
  [Read and pack the edit keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_hydro\_keys} }
  [Read and pack the hydro keys  from the above opened file.]
  
  \item \textcolor{blue}{ {\bf read\_pack\_nuclear\_keys} }
  [Read and pack the nuclear keys  from the above opened file.]\\
  
  Close above opened file.\\

  {\bf The following is performed if nrst $>$ 0, ny = 1, nz = 1 (restarting a 1D problem} \\
  
  nouttmp = 1: Open unformated {\bf Data\_Path/Restart/rst\_tmp1\_model.d}
    
  nouttmp = 2: Open unformated {\bf Data\_Path/Restart/rst\_tmp2\_model.d}
    
  nouttmp = 3: Open unformated {\bf Data\_Path/Restart/restart\_modelXXXXXXX.d}
    
  nouttmp = 4: Open unformated {\bf Data\_Path//Restart/restart\_final\_mod.d}
    
  nouttmp = 5: Open unformated {\bf Data\_Path/Restart/restart\_modelXXXXXXX.d}\\
  
  \item \textcolor{blue}{ {\bf read\_pack\_restart\_model} }
  [Reads and packs the model configuration.]\\
    
  Close above opened file.\\

  {\bf The following is performed if nrst $>$ 0, ny $>$ 1 and/or nz $>$ 1, and nouttmp = 5  (restarting a Multi-D problem from a 1-D precursor} \\

  Open unformated {\bf Data\_Path/Restart/restart\_modelXXXXXXX.d}\\
  
  \item \textcolor{blue}{ {\bf  read\_pack\_restart\_model} }
  [Reads and packs the model configuration.]\\
  
  Close above opened file.\\
  

\end{enumerate}
  
  {\bf The following is performed if nrst = 0 (problem is being initiated)} \\

  \item Open {\bf Data3/Initial\_Data/reset\_initial.d}\\
  Write reset\_initial.d for use as reset.d file if initiating the same simulation.
  \item Close {\bf Data3/Initial\_Data/reset\_initial.d}\\

\end{enumerate}

  \item \textcolor{blue}{ {\bf data\_check} }
  [Check array dimensions, problem dimensions, domain decomposition for cinsistency]
  
  \item \textcolor{blue}{ {\bf rezone} }
  [Set up y-grid, z-grid]\\

}

  The following is performed on all processors.\\

  Broadcast radhyd\_keys data to all processors.

  Broadcast eos\_keys data to all processors.

  Broadcast transport\_keys data to all processors.

  Broadcast e\_advect\_keys data to all processors.

  Broadcast edit\_keys data to all processors.

  Broadcast hydro\_keys data to all processors.

  Broadcast nuclear\_keys data to all processors.

  Broadcast rezone data to all processors.
  
  \item \textcolor{blue}{ {\bf unpack\_arrays} }
  [Directs the unpacking and loading into array modules of the problem keys, and for the case in which nrst = 0 (initialing a simulaion), or  ny = nz = 1 (restarting a 1-D simulation), or nouttmp = 5 (restarting a multi-D simulation from a 1-D precursor) loading the model configuration into the radial\_ray module.]

\begin{enumerate}

  \item \textcolor{blue}{ {\bf unpack\_init} }
  [Unpacks nrst, nouttmp, and the problem header, packs the first into {\bf cycle\_module} and the second and third into {\bf edit\_module} ]

  \item \textcolor{blue}{ {\bf unpack\_radial\_ray\_keys} }
  [Unpacks the radhyd\_keys and loads into {\bf radial\_ray\_module} ]

  \item \textcolor{blue}{ {\bf unpack\_rezone\_arrays} }
  [Unpacks the rezone parameters and arrays and loads into {\bf radial\_ray\_module}, {\bf evh1\_sweep}. and {\bf evh1\_global}. ]

  \item \textcolor{blue}{ {\bf unpack\_eos\_keys} }
  [Unpacks the eos\_keys and loads into {\bf eos\_snc\_x\_module}, {\bf eos\_snc\_y\_module}, {\bf eos\_snc\_z\_module}, {\bf prb\_cntl\_module}, and {\bf radial\_ray\_module}.]

  \item \textcolor{blue}{ {\bf unpack\_transport\_keys} }
  [Unpacks the transport\_keys and loads into {\bf cycle\_module}, {\bf eos\_snc\_x\_module}, {\bf it\_tol\_module}, {\bf nu\_dist\_module}, {\bf nu\_energy\_grid\_module}, {\bf prb\_cntl\_module}, and {\bf t\_cntrl\_module}.]

  \item \textcolor{blue}{ {\bf unpack\_e\_advct\_keys} }
  [Unpacks the e\_advct\_keys and loads into {\bf e\_advct\_module}.]

  \item \textcolor{blue}{ {\bf upack\_edit\_keys} }
  [Unpacks the edit\_keys and loads into {\bf edit\_module} and {\bf radial\_ray\_module}.]

  \item \textcolor{blue}{ {\bf unpack\_hydro\_keys} }
  [Unpacks the hydro\_keys and loads into {\bf bomb\_module}, {\bf convect\_module}, {\bf evh1\_global}, {\bf prb\_cntl\_module}, {\bf shock\_module}, and {\bf t\_cntrl\_module}.]

  \item \textcolor{blue}{ {\bf unpack\_nuclear\_keys} }
  [Unpacks the nuclear\_keys and loads into {\bf nucbrn\_module}, {\bf radial\_ray\_module}, {\bf eos\_snc\_x\_module}, {\bf eos\_snc\_y\_module}, and {\bf eos\_snc\_z\_module}.]\\
  
  \color{cyan}{

  If nrst = 0 (initialing a simulaion), or  ny = nz = 1 (restarting a 1-D simulation)

  \item \textcolor{blue}{ {\bf unpack\_initial\_model} }
  [Unpacks the initial model and loads into {\bf eos\_snc\_x\_module}, {\bf mdl\_cnfg\_module}, and {\bf radial\_ray\_module}.]\\
  
  }
  
\end{enumerate}
  
  \color[rgb]{0.5,0.5,0}{

  \item If nouttmp = 5 (restarting a multi-D simulation from a 1-D precursor)

  \textcolor{blue}{ {\bf unpack\_restart\_model\_to\_node} }
  [Unpacks the initial model on all processors and loads into {\bf edit\_module}, {\bf eos\_snc\_x\_module}, {\bf mdl\_cnfg\_module}, {\bf nucbrn\_module}, {\bf nu\_dist\_module}, and {\bf radial\_ray\_module}.]\\
  
   }
    
  \color[rgb]{0,0.5,0.5}{

  If nrst /= 0 and ny $>$ 1  or  nz $>$ 1 and nouttmp /= 5\\
    
  nouttmp = 1: Open unformated {\bf Data\_Path//Restart/rst\_tmp1\_`myid',.d}
    
  nouttmp = 2: Open unformated {\bf Data\_Path//Restart/rst\_tmp1\_`myid',.d}
    
  nouttmp = 3: Open unformated {\bf Data\_Path/Restart/restart\_mode`myid'\_XXXXXXX.d}
    
  nouttmp = 4: Open unformated {\bf Data\_Path//Restart/restart\_final\_mod`myid'.d}\\


  
  \textcolor{blue}{ {\bf read\_restart\_model\_to\_node} }
  [Reads in the model configuration on each processor and loads the data into  {\bf edit\_module}, {\bf eos\_snc\_x\_module}, {\bf mdl\_cnfg\_module}, {\bf nucbrn\_module}, {\bf nu\_dist\_module}, and {\bf radial\_ray\_module}.]
      
  }

  \color{black}{

  \item \textcolor{blue}{ {\bf model\_check} }
  [Checks to ensure that the actual model dimensions are consistent with the declared model dimensions.]

  \item \textcolor{blue}{ {\bf nse\_set} }
  [Loads the nse array flags into {\bf eos\_snc\_x\_module}, {\bf nucbrn\_module}, and {\bf radial\_ray\_module}.]
  
  \item \textcolor{blue}{ {\bf ye\_fix} }
  [Adjusts the electron fraction in nonNSE zones to be consistent with the composition.]
  
  \item \textcolor{blue}{ {\bf solid\_angle} }
  [Computes the solid angle subtended by each radial ray.]
    
  \item \textcolor{blue}{ {\bf problem\_setup} }
  [Directs the computation of the dependent variables needed to begin the simulation.]

 }

\begin{enumerate}
  
{\color{cyan}

  \item The following is performed if nrst = 0:

  \item \textcolor{blue}{ {\bf setup\_initial\_hydro} }
  [Computes the dependent variables in the hydro sector.]

\begin{enumerate}

  \item Compute pseudoviscous multipliers (for edit purposes)
  
  \item Set optional prescribed values of velocities.

  \item \textcolor{blue}{ {\bf pblmst1} }
  [Optionally modify problem before GR or transport sector dependent variables computed.]

  \item \textcolor{blue}{ {\bf esrgnz\_x} }
  [Load eos table arrays.]

  \item \textcolor{blue}{ {\bf eqstz\_x} }
  [Interpolate eos quantities.]

  \item \textcolor{blue}{ {\bf gammaz\_x} }
  [Compute adiabatic exponents.]
  
  \item Put NSE composition (protons, neutrons, helium, and representative heavy nucleus) in composition arrays.
  
  \item Compute pressure boundary condition at outer edge.

\end{enumerate}

  \item \textcolor{blue}{ {\bf angular\_ave} }
  [Compute the angular averages of quantities.]

  \item \textcolor{blue}{ {\bf regridder} }
  [Adjust the radial grid to maintain constant Delta rho/rho from the center to the NSE-nonNSE boundary.]
  
  }
    
  \color[rgb]{0,0.5,0.5}{

  \item The following is performed if nrst $>$ 0:

  \item \textcolor{blue}{ {\bf setup\_restart\_hydro} }
  [Computes the dependent variables in the hydro sector.]

\begin{enumerate}

  \item Compute pseudoviscous multipliers (for edit purposes)
  
  \item Set optional prescribed values of velocities.

  \item \textcolor{blue}{ {\bf pblmst1} }
  [Optionally modify problem before GR or transport sector dependent variables computed.]

  \item \textcolor{blue}{ {\bf esrgnz\_x} }
  [Load eos table arrays.]

  \item \textcolor{blue}{ {\bf eqstz\_x} }
  [Interpolate eos quantities.]

  \item \textcolor{blue}{ {\bf gammaz\_x} }
  [Compute adiabatic exponents.]
  
  \item Put NSE composition (protons, neutrons, helium, and representative heavy nucleus) in composition arrays.
  
  \item Compute pressure boundary condition at outer edge.

\end{enumerate}

  \item \textcolor{blue}{ {\bf angular\_ave} }
  [Compute the angular averages of quantities.]
  
  }
  
  \item \textcolor{blue}{ {\bf initialize\_grid} }
  [Initialize final grid to initial grid.]
  
  \item \textcolor{blue}{ {\bf radhyd\_to\_poisson} }
  [Evaluate and save the weights for solid angle integration of the Poisson equation for gravity.]
  
  \item \textcolor{blue}{ {\bf e\_zone} }
  [Compute the energy zoning, as seen by a distant observer, for the neutrinos.]
  
{\color{cyan}

  \item The following is performed if nrst = 0:

  \item \textcolor{blue}{ {\bf setup\_initial\_GR} }
  [Computes the dependent variables in gravity sector when initiating a simulation.]

\begin{enumerate}

  \item \textcolor{blue}{ {\bf agr\_nu\_cal} }
  [Load neutrino lapse functions with preliminary values.]

  \item \textcolor{blue}{ {\bf enu\_cal} }
  [Correct neutrino energies for lapse, and compute coefficients of the total neutrino number and energy.]\\
  
  Iterate on the following three subroutine calls

  \item \textcolor{blue}{ {\bf radhyd\_to\_nu\_energy\_flux} }
  [Compute neutrino energy density and fluxes.]

  \item \textcolor{blue}{ {\bf angular\_ave} }
  [Compute the angular averages of quantities.]

  \item \textcolor{blue}{ {\bf radhyd\_to\_grav\_i} }
  [Direct the computation of gravity.]\\
  
  $\ldots$ \textcolor{blue}{ {\bf grav\_Newton} }
  [Compute spherically symmetric Newtonian gravity]
  
  $\ldots$ \textcolor{blue}{ {\bf greff} }
  [Compute spherically symmetric Post-Newtonian gravity]
 
  $\ldots$ \textcolor{blue}{ {\bf poisson} }
  [Compute Spherical harmonics of Newtonian gravity; add PN spherically symmetric gravity to Spherical harmonics and subtract newtonian spherically symmetric gravity]
 
  $\ldots$ \textcolor{blue}{ {\bf agr\_cal} }
  [Compute lapse functions]
   
  $\ldots$ \textcolor{blue}{ {\bf agr\_nu\_cal} }
  [Load neutrino lapse functions.]

  $\ldots$ \item \textcolor{blue}{ {\bf enu\_cal} }
  [Correct neutrino energies for lapse, and compute coefficients of the total neutrino number and energy.]

\end{enumerate}

}
    
  \color[rgb]{0,0.5,0.5}{

  \item The following is performed if nrst $>$ 0:

  \item \textcolor{blue}{ {\bf setup\_restart\_GR} }
  [Computes the dependent variables in gravity sector when restarting a simulation.]

\begin{enumerate}

  \item \textcolor{blue}{ {\bf agr\_nu\_cal} }
  [Load neutrino lapse functions with preliminary values.]

  \item \textcolor{blue}{ {\bf enu\_cal} }
  [Correct neutrino energies for lapse, and compute coefficients of the total neutrino number and energy.]\\
  
  Iterate on the following three subroutine calls

  \item \textcolor{blue}{ {\bf radhyd\_to\_nu\_energy\_flux} }
  [Compute neutrino energy density and fluxes.]

  \item \textcolor{blue}{ {\bf angular\_ave} }
  [Compute the angular averages of quantities.]

  \item \textcolor{blue}{ {\bf radhyd\_to\_grav\_i} }
  [Direct the computation of gravity.]\\
  
  $\ldots$ \textcolor{blue}{ {\bf grav\_Newton} }
  [Compute spherically symmetric Newtonian gravity]
  
  $\ldots$ \textcolor{blue}{ {\bf greff} }
  [Compute spherically symmetric Post-Newtonian gravity]
 
  $\ldots$ \textcolor{blue}{ {\bf poisson} }
  [Compute Spherical harmonics of Newtonian gravity; add PN spherically symmetric gravity to Spherical harmonics and subtract newtonian spherically symmetric gravity]
 
  $\ldots$ \textcolor{blue}{ {\bf agr\_cal} }
  [Compute lapse functions]
   
  $\ldots$ \textcolor{blue}{ {\bf agr\_nu\_cal} }
  [Load neutrino lapse functions.]

  $\ldots$ \item \textcolor{blue}{ {\bf enu\_cal} }
  [Correct neutrino energies for lapse, and compute coefficients of the total neutrino number and energy.]

\end{enumerate}

}
  
{\color{cyan}

  \item The following is performed if nrst = 0:

  \item \textcolor{blue}{ {\bf setup\_initial\_trans} }
  [Computes the dependent variables in transport sector when initiating a simulation.]
  
\begin{enumerate}

  \item \textcolor{blue}{ {\bf gamgr\_nu\_cal} }
  [Load relativistic gammas for neutrinos.]

  \item \textcolor{blue}{ {\bf gamgr\_nu\_cal} }
  [Load relativistic gammas for neutrinos.]
   
  $\ldots$ \textcolor{blue}{ {\bf agr\_nu\_cal} }
  [Load neutrino lapse functions.]

  $\ldots$ \item \textcolor{blue}{ {\bf enu\_cal} }
  [Correct neutrino energies for lapse, and compute coefficients of the total neutrino number and energy.]

  $\ldots$ \item \textcolor{blue}{ {\bf pre\_trans} }
  [Compute geometric factors and functions of the neutrino energy needed for transport.]

  $\ldots$ \item \textcolor{blue}{ {\bf pblmst2} }
  [Optionally modify the problem given the neutrino energies.]

  $\ldots$ \item \textcolor{blue}{ {\bf read\_ec\_table} }
  [Read in table of rates for electron capture on nuclei.]

  $\ldots$ \item \textcolor{blue}{ {\bf abemset} }
  [Compute neutrino absorption and emission tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scateset} }
  [Compute neutrino-electron scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scatiset} }
  [Compute neutrino-nucleon and nuclei isoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf pairset} }
  [Compute electron-positron pair annihilation rate tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf bremset} }
  [Compute neutrino-nucleon bremsstrahlung tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scatnset} }
  [Compute neutrino-nucleon nonisoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf abemrate} }
  [Interpolate neutrino-electron scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf sctirate} }
  [Interpolate neutrino-nucleon and nuclei isoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scterate} }
  [Interpolate neutrino-electron scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf pairrate} }
  [Interpolate electron-positron pair annihilation rate tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf bremrate} }
  [Interpolate neutrino-nucleon bremsstrahlung tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf sctnrate} }
  [Interpolate neutrino-nucleon nonisoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf mfp\_cal} }
  [Compute neutrino inverse mean free paths.]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_sphere} }
  [Compute neutrinospheres.]

  $\ldots$ \item \textcolor{blue}{ {\bf psi1\_cal} }
  [Compute the first angular moments of the neutrino occupation numbers.]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_number} }
  [Compute total neutrino numbers and energies,]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_stress\_x} }
  [Compute the neutrino stresses,]

  $\ldots$ \item \textcolor{blue}{ {\bf eddington} }
  [Compute total neutrino Eddington factors,]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_U} }
  [Compute the isotropic neutrino pressure and energy,]

\end{enumerate}

  }
    
  \color[rgb]{0,0.5,0.5}{

  \item The following is performed if nrst $>$ 0:

  \item \textcolor{blue}{ {\bf setup\_initial\_trans} }
  [Computes the dependent variables in transport sector when initiating a simulation.]
  
\begin{enumerate}

  \item \textcolor{blue}{ {\bf gamgr\_nu\_cal} }
  [Load relativistic gammas for neutrinos.]

  \item \textcolor{blue}{ {\bf gamgr\_nu\_cal} }
  [Load relativistic gammas for neutrinos.]
   
  $\ldots$ \textcolor{blue}{ {\bf agr\_nu\_cal} }
  [Load neutrino lapse functions.]

  $\ldots$ \item \textcolor{blue}{ {\bf enu\_cal} }
  [Correct neutrino energies for lapse, and compute coefficients of the total neutrino number and energy.]

  $\ldots$ \item \textcolor{blue}{ {\bf pre\_trans} }
  [Compute geometric factors and functions of the neutrino energy needed for transport.]

  $\ldots$ \item \textcolor{blue}{ {\bf pblmst2} }
  [Optionally modify the problem given the neutrino energies.]

  $\ldots$ \item \textcolor{blue}{ {\bf read\_ec\_table} }
  [Read in table of rates for electron capture on nuclei.]

  $\ldots$ \item \textcolor{blue}{ {\bf abemset} }
  [Compute neutrino absorption and emission tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scateset} }
  [Compute neutrino-electron scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scatiset} }
  [Compute neutrino-nucleon and nuclei isoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf pairset} }
  [Compute electron-positron pair annihilation rate tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf bremset} }
  [Compute neutrino-nucleon bremsstrahlung tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scatnset} }
  [Compute neutrino-nucleon nonisoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf abemrate} }
  [Interpolate neutrino-electron scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf sctirate} }
  [Interpolate neutrino-nucleon and nuclei isoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf scterate} }
  [Interpolate neutrino-electron scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf pairrate} }
  [Interpolate electron-positron pair annihilation rate tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf bremrate} }
  [Interpolate neutrino-nucleon bremsstrahlung tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf sctnrate} }
  [Interpolate neutrino-nucleon nonisoenergetic scattering tables.]

  $\ldots$ \item \textcolor{blue}{ {\bf mfp\_cal} }
  [Compute neutrino inverse mean free paths.]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_sphere} }
  [Compute neutrinospheres.]

  $\ldots$ \item \textcolor{blue}{ {\bf psi1\_cal} }
  [Compute the first angular moments of the neutrino occupation numbers.]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_number} }
  [Compute total neutrino numbers and energies,]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_stress\_x} }
  [Compute the neutrino stresses,]

  $\ldots$ \item \textcolor{blue}{ {\bf eddington} }
  [Compute total neutrino Eddington factors,]

  $\ldots$ \item \textcolor{blue}{ {\bf nu\_U} }
  [Compute the isotropic neutrino pressure and energy,]

\end{enumerate}

  }

\end{enumerate}

  \item \textcolor{blue}{ {\bf network\_setup} }
  [Reads in and broadcasts the nuclear and reaction rate data for the nuclear network.]
  
  \item \textcolor{blue}{ {\bf load\_evh1\_arrays} }
  [loads EVH1 parameters into {\bf radial\_ray\_module}, {\bf evh1\_bound} and {\bf evh1\_global}.]
  
  \item \textcolor{blue}{ {\bf time\_step\_check} }
  [Computes the minimum Courant time]\\

\end{enumerate}

  \item \textcolor{blue}{ {\bf radhyd\_to\_edit} }
  [Performs the initial edit of the model.] 

  \item \textcolor{blue}{ {\bf radhyd\_to\_monitor\_MPI} }
  [Computes initial values for monitoring energy and lepton conservation.] 

\end{enumerate}

\end{itemize}

\end{document}
