/* 
 * ADIOS is freely available under the terms of the BSD license described
 * in the COPYING file in the top level directory of this source distribution.
 *
 * Copyright (c) 2008 - 2009.  UT-BATTELLE, LLC. All rights reserved.
 */

/* Application that performs computation and communication to a user-given ratio.
   Then it performs output I/O with posix, parallel hdf5 and adios.
   It writes a global 2D array of N*NX x NY, where N is the number of processes and
   NX, NY are user-given sizes.
   
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <malloc.h>
//#include <unistd.h>
//#include <fcntl.h>
#include <errno.h>
#include "mpi.h"
#include "output.h"
#include "timing.h"


// User parameters
int    nsteps;            // number of output steps
int    niterations;       // number of iterations between steps
int    tcomp;             // Time for computation in one iteration, in millisec
int    tcomm;             // Time for communication in one iteration, in millisec
int    nx;                // array size in x direction
int    ny;                // array size in y direction


void printUsage(char *prgname)
{
    printf("Usage: mpirun -np <N> %s <steps>  <it>  <tcomp>  <tcomm>  <nx>  <ny>\n"
           "  <steps>   number of steps (outputs)\n"
           "  <it>      number of iterations in each step (between outputs)\n"
           "\n"
           "  <tcomp>   computation time per iteration (in millisec)"
           "  <tcomm>   communication time per iteration (in millisec)"
           "\n"
           "  <nx> <ny> size of a 2D array generated by each process\n"
           "            The output 2D array will be <N>*<nx> times <ny>\n"
           "            e.g. for N=12 nx=4 ny=3, output will be 48x3\n"
        ,prgname);
}

int convert_arg_to_int (char **argv, int argpos, char *name, int *value)
{
    char *end;
    errno = 0;
    *value = strtol(argv[argpos], &end, 10);
    if (errno || (end != 0 && *end != '\0')) {
        printf ("ERROR: Invalid argument for %s: '%s'\n", name, argv[argpos]);
        printUsage(argv[0]);
        return 1;
    }
    return 0;
}

int processArgs(int argc, char ** argv)
{
    if (argc < 7) {
        printUsage (argv[0]);
        return 1;
    }

    if (convert_arg_to_int (argv, 1, "<steps>", &nsteps)) 
        return 1;
    if (convert_arg_to_int (argv, 2, "<it>", &niterations)) 
        return 1;
    if (convert_arg_to_int (argv, 3, "<tcomp>", &tcomp)) 
        return 1;
    if (convert_arg_to_int (argv, 4, "<tcomm>", &tcomm)) 
        return 1;
    if (convert_arg_to_int (argv, 5, "<nx>", &nx)) 
        return 1;
    if (convert_arg_to_int (argv, 6, "<ny>", &ny)) 
        return 1;

    return 0;
}

// other global variables
MPI_Comm  comm;
int    rank;
int    nproc;             // # of total procs
int    ncomp;             // number of computation units to get tcomp (without I/O)
int    ncomm;             // number of communication units to get tcomm (without I/O)
int    offs_x, offs_y;    // offset in x and y direction
int    gnx, gny;          // global array size
double * data;            // data array to do calc on it and output

// communication array
#define NELEMS 8192    // 32 KB of integers
int    sendbuf[NELEMS];     // array to do communication with it
int    recvbuf[NELEMS];     // array to do communication with it

void data_init()
{
    int i,j;
    for (i = 0; i < nx; i++) {
        for (j = 0; j < ny; j++) {
            data[i*ny + j] = 1.0*rank;
        }
    }


    for (i = 0; i < NELEMS; i++)
        sendbuf[i] = rank;
}

void do_calc_unit()
{
    int i,j;
    double tmp;
    for (i = 0; i < nx; i++) {
        for (j = 0; j < ny/2; j++) {
            tmp = data[i*ny + j];
            data[i*ny + j] = data[i*ny + (ny-j-1)];
            data[i*ny + (ny-j-1)] = tmp;
        }
    }
}

void do_comm_unit()
{
    // rank 0: reduce data from everybody
    MPI_Reduce (sendbuf, recvbuf, NELEMS, MPI_INTEGER, MPI_MAX, 0, comm);
    //MPI_Bcast (sendbuf, NELEMS, MPI_INTEGER, 0, comm);
}

void determine_computation_ratio ()
{
    /* run computation and communication for a while and establish
       how many times of each needs to be performed to get the desired ratio
       tcomp --> comp_n and tcomm --> comm_n
    */
    double wb, ttotal;
    // run for tcomp milliseconds
    ncomp = 0;
    ttotal = 0.0;
    if (!rank) printf ("  # of calc units to get %g sec computation...", tcomp/1000.0);
    while (ttotal < tcomp/1000.0) {
        wb = MPI_Wtime();
        do_calc_unit();
        ttotal += MPI_Wtime() - wb;
        ncomp++;
    }
    if (!rank) printf (" = %d. avg unit time = %g sec\n", ncomp, ttotal/ncomp);

    // run for tcomm milliseconds
    ncomm = 0;
    ttotal = 0.0;
    if (!rank) printf ("  # of comm units to get %g sec communication...", tcomm/1000.0);
    MPI_Barrier (comm);
    while (ttotal < tcomm/1000.0) {
        wb = MPI_Wtime();
        do_comm_unit();
        ttotal += MPI_Wtime() - wb;
        // use rank 0's ttotal for everyone
        MPI_Bcast (&ttotal, 1, MPI_DOUBLE, 0, comm);
        ncomm++;
    }
    if (!rank) printf (" = %d. avg unit time = %g sec\n", ncomm, ttotal/ncomm);
    // use rank 0's ncomm for everyone
    MPI_Bcast (&ncomm, 1, MPI_INTEGER, 0, comm);
}


int main (int argc, char ** argv ) 
{
    int i;
    MPI_Init (&argc, &argv);
    MPI_Comm_dup (MPI_COMM_WORLD, &comm);
    MPI_Comm_rank (comm, &rank);
    MPI_Comm_size (comm, &nproc);

    if (processArgs(argc, argv)) {
        return 1;
    }

    if (!rank) {
        printf ("Setup parameters:\n");
        printf ("  # of steps (outputs):     %d\n", nsteps);
        printf ("  # of iterations per step: %d\n", niterations);
        printf ("  computation:    %g sec per iteration\n", tcomp/1000.0);
        printf ("  commmunication: %g sec per iteration\n", tcomm/1000.0);
        printf ("  output size per process: %d x %d doubles = %lld bytes\n", nx, ny, sizeof(double) * nx * (uint64_t) ny);
        printf ("  output size per step: %lld bytes\n", nproc * sizeof(double) * nx * (uint64_t) ny);
    }

    //2D array with 1D decomposition
    offs_x = rank * nx;
    offs_y = 0;
    gnx = nproc * nx;
    gny = ny;

    data = (double*) malloc (sizeof(double) * nx * (size_t) ny);
    timing_alloc(nsteps);

    /* Test phase to calculate ncomp and ncomm */
    data_init();
    for (i=1; i<=20; i++) {
        if (!rank) printf ("Testing speed (warm up %d)...\n", i);
        MPI_Barrier (comm);
        determine_computation_ratio ();
    }
    if (!rank) printf ("Testing speed (to determine calc/comm units)...\n");
    determine_computation_ratio ();
    if (!rank) {
        printf ("Test phase completed.\n");
        printf ("  # of computation units in each iteration:   %d\n", ncomp);
        printf ("  # of communication units in each iteration: %d\n", ncomm);
    }

    int bufsizeMB = nx*ny*sizeof(double)/1048576 + 1;
    output_init(comm, bufsizeMB);
    output_define(nx, ny, gnx, gny, offs_x, offs_y);


    /* Do the steps with output now */
    data_init();
    MPI_Barrier (comm);
    int it, step, icomp, icomm;
    double Tcalc_it, Tcomm_it;
    char filename[256];
    for (step=0; step < nsteps; step++) {
        if (!rank) printf ("Start step %d\n", step);
        Tcalc[step] = 0;
        Tcomm[step] = 0;
        for (it=0; it < niterations; it++) {
            // spend 'tcomp' time with computation
            Tcalc_it = MPI_Wtime();
            for (icomp=0; icomp < ncomp; icomp++) {
                do_calc_unit();
            }
            Tcalc_it = MPI_Wtime() - Tcalc_it;
            Tcalc[step] += Tcalc_it;

            // spend 'tcomm' time with communication
            Tcomm_it = MPI_Wtime();
            for (icomm=0; icomm < ncomm; icomm++) {
                do_comm_unit();
            }
            Tcomm_it = MPI_Wtime() - Tcomm_it;
            Tcomm[step] += Tcomm_it;
        }
        // output per step
        snprintf (filename, sizeof(filename), "data%6.6d", step);
        if (!rank) printf ("Output to %s\n", filename);
        MPI_Barrier (comm);
        output_dump(filename, step, data);
    }

    if (!rank) printf ("Finalize...\n");
    MPI_Barrier (comm);
    output_finalize (rank);

    if (!rank) timing_report(nsteps);
    free (data);
    timing_free();

    MPI_Barrier (comm);
    MPI_Finalize ();
    return 0;
}
