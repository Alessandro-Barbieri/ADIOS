%\chapter*{{\Large \textbf{12 C Programming with ADIOS}}}
\chapter{C Programming with ADIOS}

This chapter focuses on how to integrate ADIOS into the users' source code in C 
and how to write into separate files or a shared file from multiple processes in 
the same communication domain. These examples can be found in the source distribution 
under the examples/C/manual directory.

In the following steps we will create programs that use ADIOS to write

- a metadata-rich BP file per process

- one large BP file with the arrays from all processes

- N files from P processes, where N \texttt{<}\texttt{<} P

- the data of all processes as one global array into one file

- a global-array over several timesteps into one file

The strength of the componentization of I/O in ADIOS allows us to switch between 
the first two modes by selecting a different transport method in a configuration 
file and run the program without recompiling it. 

\section{Non-ADIOS Program}

The starting programming example, shown in Figure 23, writes a double-precision 
array t with size of NX into a separate file per process (the array is uninitialized 
in the examples). 

\#include \texttt{<}stdio.h\texttt{>}

\#include \texttt{"}mpi.h\texttt{"}

\#include \texttt{"}adios.h\texttt{"}

int main (int argc, char ** argv) 

\{

\leftskip=18pt
char      \textbf{    } filename [256];

int              rank;

int              NX\textbf{ }=\textbf{ }10;

double      t[NX];

FILE          * fp;

MPI\_Init (\&argc, \&argv);

MPI\_Comm\_rank (MPI\_COMM\_WORLD, \&rank);

sprintf (filename, \texttt{"}restart\_\%5.5d.dat\texttt{"}, rank);

fp = open (filename, \texttt{"}w\texttt{"});

fwrite ( \&NX, sizeof(int), 1, fp);

fwrite (t,  sizeof(double), NX, fp);

fclose (fp);

MPI\_Finalize ();

return 0;

\leftskip=0pt
\}

\label{HRef119579280}\label{HToc144350182}

\leftskip=18pt
{\color{color20} \textbf{Figure 23. Original program (examples/C/manual/1\_nonadios\_example.c).}}

\leftskip=0pt
\$ mpirun -np 4 1\_nonadios\_example

\$ ls restart\_*

restart\_00000.dat  restart\_00001.dat  restart\_00002.dat  restart\_00003.dat\label{HToc84890292}\label{HToc212016668}\label{HToc212016910}\label{HToc182553441}

\section{Construct an XML File}

In the example above, the program is designed to write a file for each process. 
There is a double-precision one-dimensional array called ``t''. We also need to 
declare and write all variables that are used for dimensions (i.e. NX in our example). 
Therefore, our configuration file is constructed as shown in Figure 24.

/* config.xml*/

\texttt{<}?xml version=\texttt{"}1.0\texttt{"}?\texttt{>}

\texttt{<}adios-config host-language=\texttt{"}C\texttt{"}\texttt{>}

\parindent=14pt
\texttt{<}adios-group name=\texttt{"}temperature\texttt{"} coordination-communicator=\texttt{"}comm\texttt{"}\texttt{>}

\parindent=28pt
\texttt{<}var name=\texttt{"}NX\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\texttt{<}var name=\texttt{"}temperature\texttt{"} gwrite=\texttt{"}t\texttt{"} 
type=\texttt{"}double\texttt{"} dimensions=\texttt{"}NX\texttt{"}/\texttt{>}

\parindent=10pt
\texttt{<}attribute name=\texttt{"}description\texttt{"} path=\texttt{"}/temperature\texttt{"} 
 type=''string''

\parindent=68pt
value=\texttt{"}Temperature array\texttt{"} /\texttt{>}

\parindent=0pt
\texttt{<}/adios-group\texttt{>}

\texttt{<}method group=\texttt{"}temperature\texttt{"} method=\texttt{"}POSIX\texttt{"}/\texttt{>}

\texttt{<}buffer size-MB=\texttt{"}1\texttt{"} allocate-time=\texttt{"}now\texttt{"}/\texttt{>}

\texttt{<}/adios-config\texttt{>}

\label{HRef119579330}\label{HToc144350183}

\leftskip=18pt
{\color{color20} \textbf{Figure 24. Example config.xml file\label{HToc84890293}\label{HToc212016669}\label{HToc212016911}\label{HToc182553442}}}

\section{Generate .ch file (s)}

\leftskip=0pt
The adios\_group\_size function and a set of adios\_write functions can be automatically 
generated in gwrite\_temperature.ch file by using the following python command: 

gpp.py config.xml

The generated gwrite\_temperature.ch file is shown in Figure 25.

/* gwrite\_temperature.ch */

adios\_groupsize = 4 \textbackslash{}

\parindent=57pt
+ 8 * (NX);

\parindent=0pt
adios\_group\_size (adios\_handle, adios\_groupsize, \&adios\_totalsize);

adios\_write (adios\_handle, \texttt{"}NX\texttt{"}, \&NX);

adios\_write (adios\_handle, \texttt{"}temperature\texttt{"}, t);

\label{HRef119579365}\label{HToc144350184}

\leftskip=18pt
{\color{color20} \textbf{Figure 25. Example gwrite\_temperature.ch file\label{HToc84890294}\label{HToc212016670}\label{HToc212016912}\label{HToc182553443}}}

\section{POSIX transport method (P writers, P subfiles + 1 metadata file)}

For our first program, we simply translate the program of Figure 23, so that all 
of the I/O operations are done with ADIOS routines. The POSIX method can be used 
to write out separate files for each processor in Figure 26. The changes to the 
original example are highlighted. We need to use an MPI communicator in adios\_open() 
because the subprocesses need to know the rank to create unique subfile names. 

/*write Separate file for each process by using POSIX*/

\#include \texttt{<}stdio.h\texttt{>}

\#include \texttt{"}mpi.h\texttt{"}

{\color{color02} \#include \texttt{"}adios.h\texttt{"}}

int main (int argc, char ** argv) 

\{

\leftskip=18pt
char      \textbf{    } filename [256];

int              rank;

int              NX\textbf{ }=\textbf{ }10;

double      t[NX];

/* ADIOS variables declarations for matching gwrite\_temperature.ch */

{\color{color02} int                  adios\_err;}

{\color{color02} uint64\_t       adios\_groupsize, adios\_totalsize;}

{\color{color02} int64\_t          adios\_handle;}

{\color{color02} MPI\_Comm  * comm =  MPI\_COMM\_WORLD;}

MPI\_Init (\&argc, \&argv);

MPI\_Comm\_rank (MPI\_COMM\_WORLD, \&rank);

sprintf (filename, \texttt{"}{\color{color02} restart.bp}\texttt{"});

{\color{color02} adios\_init (\texttt{"}config.xml\texttt{"});}

{\color{color02} adios\_open (\&adios\_handle, \texttt{"}temperature\texttt{"}, 
filename, \texttt{"}w\texttt{"}, \&comm);}

{\color{color02} \#include \texttt{"}gwrite\_temperature.ch\texttt{"}}

{\color{color02} adios\_close (adios\_handle);}

{\color{color02} adios\_finalize (rank);}

MPI\_Finalize ();

return 0;

\leftskip=0pt
\}

\label{HRef119579429}\label{HToc144350185}

\begin{center}
{\color{color20} \textbf{Figure 26. Example adios program to write P files from 
P processors (examples/C/manual/2\_adios\_write.c)}}
\end{center}

The POSIX method makes a directory to store all subfiles. As for the naming of 
the directory, it appends ``.dir'' to the name the file, e.g., restart.bp.dir. 
For each subfile, it appends the rank of the process (according to the supplied 
communicators) to the name of the file (here restart.bp), so for example process 
2 will write a file restart.bp.dir/restart.bp.2. To facilitate reading of subfiles, 
the method also generates a global metadata file (restart.bp) which tracks all 
the variables in each subfile. 

\$ mpirun -np 4 2\_adios\_write

\$ ls restart.bp

restart.bp

restart.bp.dir:

restart.bp.0  restart.bp.1  restart.bp.2  restart.bp.3

\$ bpls -lad restart.bp.dir/restart.bp.2 -n 10

\parindent=7pt
integer    /NX                       scalar = 10 

double     /temperature              \{10\} = 20 / 29 

\parindent=14pt
(0)    20 21 22 23 24 25 26 27 28 29 

\parindent=0pt
string     /temperature/description  attr   = \texttt{"}Temperature array\texttt{"}\label{HToc84890296}\label{HToc212016672}\label{HToc212016914}\label{HToc182553444}

\section{MPI-IO transport method (P writers, 1 file)}

Based on the same group description in the configure file and the header file (.ch) 
generated by python script, we can switch among different transport methods without 
changing or recompiling the source code.

One entry change in the config.xml file can switch from POSIX to MPI:

\leftskip=18pt
\texttt{<}method group=''temperature'' method=''{\color{color02} \textbf{MPI''}}/\texttt{>}

\leftskip=0pt
The MPI communicator is passed as an argument of adios\_open(). Because it is defined 
as MPI\_COMM\_WORLD in the posix example already, the program does not need to 
be modified or recompiled.

\$ mpirun -np 4 2\_adios\_write

\$ ls restart.bp

restart.bp

\$ bpls -l restart.bp

Group temperature:

\parindent=7pt
integer    /NX           scalar = 10 

double     /temperature  {\color{color06} \textbf{\{10\}}} = 0 / 39

\parindent=0pt
There are several ways to verify the binary results. We can either choose bpdump 
to display the content of the file or use one of the converters (bp2ncd, bp2h5, 
or bp2ascii), to produce the user's preferred file format (NetCDF, HDF5 or ASCII, 
respectively) and use its dump utility to output the content in the standard output. 
Bpls cannot list the individual arrays written by the processes because the generic 
read API it uses does not support this (it can see only one of them as the size 
of /temperature suggest in the listing above). It is suggested to use global arrays 
(see example below) to present the data written by many processes as one global 
array, which then can be listed and any slice of it can be read/dumped. 

This example, however, can be used for checkpoint/restart files where the application 
would only read in data from the same number of processes as it was written (see 
next example). The transparent switch between the POSIX and MPI methods allows 
the user choose the better performing method for a particular system without changing 
the source code. \label{HToc84890297}\label{HToc212016673}\label{HToc212016915}\label{HToc182553445}

\section{Reading data from the same number of processors}

Now let's move to examples of how to read the data from BP or other files.  Assuming 
that we still use the same configure file shown in Figure 24, the following steps 
illustrate how to easily change the code and xml file to read a variable. 

1. add another variable adios\_buf\_size specifying the size for read.

2. call adios\_open with ``r'' (read only) mode.

3. Insert \#include ``gread\_temperature.ch''

/*Read in data on same number of processors */

\#include \texttt{<}stdio.h\texttt{>}

\#include \texttt{"}mpi.h\texttt{"}

\#include \texttt{"}adios.h\texttt{"}

int main (int argc, char ** argv) 

\{

\leftskip=18pt
char      \textbf{    } filename [256];

int              rank;

int              NX\textbf{ }=\textbf{ }10;

double      t[NX];

/* ADIOS variables declarations for matching gread\_temperature.ch */

int                  adios\_err;

uint64\_t       adios\_groupsize, adios\_totalsize{\color{color02} , adios\_buf\_size};

int64\_t          adios\_handle;

MPI\_Comm  comm =  MPI\_COMM\_WORLD;

MPI\_Init (\&argc, \&argv);

MPI\_Comm\_rank (MPI\_COMM\_WORLD, \&rank);

sprintf (filename, \texttt{"}restart.bp\texttt{"});

adios\_init (\texttt{"}config.xml\texttt{"});

adios\_open (\&adios\_handle, \texttt{"}temperature\texttt{"}, filename, {\color{color02} \texttt{"}r\texttt{"}}, 
\&comm);

{\color{color02} \#include \texttt{"}gread\_temperature.ch\texttt{"}}

adios\_close (adios\_handle);

adios\_finalize (rank);

MPI\_Finalize ();

return 0;

\leftskip=0pt
\}

\label{HRef119580520}\label{HToc144350186}

\begin{center}
{\color{color20} \textbf{Figure 27. Read in data generated by 2\_adios\_write using 
gread\_temperature.ch}}

{\color{color20} \textbf{(examples/C/manual/3\_adios\_read.c)}}
\end{center}

The gread\_temperature.ch file generated by gpp.py is the following:

/* gread\_temperature.ch */

adios\_group\_size (adios\_handle, adios\_groupsize, \&adios\_totalsize);

adios\_buf\_size = 4;

adios\_read (adios\_handle, \texttt{"}NX\texttt{"}, \&NX, adios\_buf\_size);

adios\_buf\_size = NX;

adios\_read (adios\_handle, \texttt{"}temperature\texttt{"}, t, adios\_buf\_size);

\label{HToc144350187}

\leftskip=18pt
{\color{color20} \textbf{Figure 28. Example of a generated gread\_temperature.ch 
file\label{HToc182553446}}}

\section{Writing to Shared Files (P writers, N files)}

\leftskip=0pt
As the number of processes increases to tens or hundreds of thousands, the amount 
of files will increase by the same magnitude if we use the POSIX method or a single 
shared file may be too large if we use the MPI method. In this example we address 
a scenario in which multiple processes write to N files. In the following example 
(Figure 29), we write out N files from P processes. This is achieved by creating 
a separate communicator for N subsets of the processes using MPI\_Comm\_split(). 

\#include \texttt{<}stdio.h\texttt{>}

\#include \texttt{"}mpi.h\texttt{"}

\#include \texttt{"}adios.h\texttt{"}

int main (int argc, char ** argv) 

\{

\leftskip=18pt
char      \textbf{    } filename [256];

int              rank, size;

int              NX\textbf{ }=\textbf{ }10; 

{\color{color02} int              N = 3;}

double      t[NX];

/* ADIOS variables declarations for matching gwrite\_temperature.ch */

int        \textbf{         }adios\_err;

uint64\_t      adios\_groupsize, adios\_totalsize;

int64\_t     adios\_handle;

MPI\_Comm comm;

/* 

int              color, key;

MPI\_Init (\&argc, \&argv);

MPI\_Comm\_rank (MPI\_COMM\_WORLD, \&rank);

MPI\_Comm\_size (MPI\_COMM\_WORLD, \&size);

/* MPI\_Comm\_split partitions the world group into N disjointed  subgroups, 

\parindent=7pt
* the processes are ranked in terms of the argument key  

*  a new communicator comm is returned for this specific grid configuration

*/

\parindent=0pt
{\color{color02} \textbf{color = rank \% N;}}

{\color{color02} \textbf{key = rank / N;}}

{\color{color02} \textbf{MPI\_Comm\_split (MPI\_COMM\_WORLD, color, key, \&comm);}}

/* every P/N processes write into the same file 

\parindent=7pt
* there are N files generated. 

*/

\parindent=0pt
{\color{color02} \textbf{sprintf (filename, \texttt{"}restart\_\%5.5d.bp\texttt{"}, 
color);}}

adios\_init (\texttt{"}config.xml\texttt{"});

adios\_open (\&adios\_handle, \texttt{"}temperature\texttt{"}, filename, \texttt{"}w\texttt{"}, 
\&comm);

\#include \texttt{"}gwrite\_temperature.ch\texttt{"}

adios\_close (adios\_handle);

adios\_finalize (rank);

MPI\_Finalize ();

return 0;

\leftskip=0pt
\}

\label{HRef119579635}\label{HToc144350188}

\leftskip=18pt
{\color{color20} \textbf{Figure 29. Example ADIOS program writing N files from 
P processors (N)}}

\leftskip=0pt
The reconstructed MPI communicator comm is passed as an argument of the adios\_open() 
call. Therefore, in this example, each file is written by the processes in the 
same communication domain.

There is no need to change the XML file in this case because we are still using 
the MPI method. \label{HToc84890299}\label{HToc212016675}\label{HToc212016917}\label{HRef119999389}\label{HToc182553447}

\section{Global Arrays}
\label{section-globalarrays}

If each process writes out a sub-array that belongs to the same global space, ADIOS 
provides the way to write out global information so the generic read API can see 
a single global array (and also the HDF5 or NetCDF file when using our converters). 
This example demonstrates how to write global arrays, where the number of processes 
becomes a separate dimension. Each process is writing the one dimensional temperature 
array of size NX and the result is a two dimensional array of size PxNX. Figure 
30 shows how to define a global array in the XML file. 

\texttt{<}?xml version=\texttt{"}1.0\texttt{"}?\texttt{>}

\texttt{<}adios-config host-language=\texttt{"}C\texttt{"}\texttt{>}

\parindent=14pt
\texttt{<}adios-group name=\texttt{"}temperature\texttt{"} coordination-communicator=\texttt{"}comm\texttt{"}\texttt{>}

\parindent=28pt
\texttt{<}var name=\texttt{"}NX\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\texttt{<}var name=\texttt{"}size\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\parindent=57pt
\texttt{<}var name=\texttt{"}rank\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\parindent=0pt
{\color{color02} \texttt{<}global-bounds dimensions=\texttt{"}size,NX\texttt{"} 
offsets=\texttt{"}rank,0\texttt{"}\texttt{>}}

\parindent=7pt
{\color{color02} \texttt{<}var name=\texttt{"}temperature\texttt{"} gwrite=\texttt{"}t\texttt{"} 
type=\texttt{"}double\texttt{"} dimensions=\texttt{"}1,NX\texttt{"}/\texttt{>}}

\parindent=0pt
{\color{color02} \texttt{<}/global-bounds\texttt{>}}

\parindent=28pt
\texttt{<}attribute name=\texttt{"}description\texttt{"} path=\texttt{"}/temperature\texttt{"}

\parindent=72pt
value=\texttt{"}Global array written from 'size' processes\texttt{"} type=\texttt{"}string\texttt{"}/\texttt{>}

\parindent=14pt
\texttt{<}/adios-group\texttt{>}

\parindent=0pt
\texttt{<}method group=\texttt{"}temperature\texttt{"} method=\texttt{"}MPI\texttt{"}/\texttt{>}

\texttt{<}buffer size-MB=\texttt{"}2\texttt{"} allocate-time=\texttt{"}now\texttt{"}/\texttt{>}

\texttt{<}/adios-config\texttt{>} 

\label{HRef119581446}\label{HToc144350189}

\begin{center}
{\color{color20} \textbf{Figure 30. Config.xml for a global array }}

{\color{color20} \textbf{(examples/C/global-array/adios\_global.xml)\label{HToc212017568}\label{HToc212017704}}}
\end{center}

The variable is inserted into a \texttt{<}global-bounds\texttt{>}...\texttt{<}/global-bounds\texttt{>} 
section. The global array's global dimension is defined by the variables size and 
NX, available in all processes and all with the same value. The offset of a local 
array written by a process is defined using the rank variable, which is different 
on every process.

The variable itself is defined as an 1xNX two dimensional array, although in the 
C code it is still a one dimensional array. 

The gwrite header file generated by gpp.py is the following:

/* gwrite\_temperature.ch */

adios\_groupsize = 4 \textbackslash{}

\parindent=115pt
+ 4 \textbackslash{}

+ 4 \textbackslash{}

\parindent=230pt
+ 8 * (1) * (NX);

\parindent=0pt
adios\_group\_size (adios\_handle, adios\_groupsize, \&adios\_totalsize);

adios\_write (adios\_handle, \texttt{"}NX\texttt{"}, \&NX);

{\color{color02} adios\_write (adios\_handle, \texttt{"}size\texttt{"}, \&size);}

{\color{color02} adios\_write (adios\_handle, \texttt{"}rank\texttt{"}, \&rank);}

adios\_write (adios\_handle, \texttt{"}temperature\texttt{"}, t);

\label{HToc144350190}

\leftskip=18pt
{\color{color20} \textbf{Figure 31. gwrite header file generated from config.xml}}

\leftskip=0pt
The program code is not very different from the one used in the above example. 
It needs to have the size and rank variables in the code defined (see examples/C/global-array/adios\_global.c) 
\label{HToc182553448}

\subsection{MPI-IO transport method (P writers, 1 file)}

\$ mpirun -np 4 ./adios\_global

\$ ls adios\_global.bp 

adios\_global.bp

\$  bpls -latd adios\_global.bp -n 10

integer    /NX                       scalar = 10

\parindent=3pt
integer    /rank                     scalar = 0

integer    /size                     scalar = 4

\parindent=7pt
double     /temperature              \{4, 10\} = 0 / 39 / 19.5 / 11.5434  \{MIN 
/ MAX / AVG / STD\_DEV\}

\parindent=14pt
(0,0)    0 1 2 3 4 5 6 7 8 9

(1,0)    10 11 12 13 14 15 16 17 18 19

\parindent=28pt
(2,0)    20 21 22 23 24 25 26 27 28 29

\parindent=14pt
(3,0)    30 31 32 33 34 35 36 37 38 39

\parindent=7pt
string     /temperature/description  attr   = \texttt{"}Global array written from 
'size' processes\texttt{"}

\parindent=0pt
The bp2ncd utility can be used to convert the bp file to an NetCDF file:

\$ bp2ncd adios\_global.bp

\$ ncdump adios\_global.nc 

netcdf adios\_global \{

dimensions:

\parindent=28pt
NX = 10 ;

size = 4 ;

\parindent=57pt
rank = 1 ;

\parindent=0pt
variables:

\parindent=28pt
double temperature(size, NX) ;

\parindent=57pt
temperature:description = \texttt{"}Global array written from \textbackslash{}'size\textbackslash{}' 
processes\texttt{"} ;

\parindent=0pt
data:

\parindent=3pt
temperature =

\parindent=7pt
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,

10, 11, 12, 13, 14, 15, 16, 17, 18, 19,

\parindent=14pt
20, 21, 22, 23, 24, 25, 26, 27, 28, 29,

\parindent=7pt
30, 31, 32, 33, 34, 35, 36, 37, 38, 39 ;

\parindent=0pt
\}\label{HToc182553449}

\subsection{POSIX transport method (P writers, P Subfiles + 1 Metadata file)}

To list variables output from POSIX transport, user only needs to specify the global 
metadata file (e.g., adios\_global.bp) as a parameter to bpls, not each individual 
files (e.g., adios\_global.bp.dir/adios\_global.bp.0). The output of the POSIX 
and the MPI methods are equivalent from reading point of view. 

\$ mpirun -np 4 ./adios\_global

\$ ls adios\_global.bp 

adios\_global.bp

\$  bpls -latd adios\_global.bp -n 10

integer    /NX                       scalar = 10

\parindent=3pt
integer    /rank                     scalar = 0

integer    /size                     scalar = 4

\parindent=7pt
double     /temperature              \{4, 10\} = 

\parindent=0pt
0 / 39 / 19.5 / 11.5434  \{MIN / MAX / AVG / STD\_DEV\}

\parindent=14pt
(0,0)    0 1 2 3 4 5 6 7 8 9

(1,0)    10 11 12 13 14 15 16 17 18 19

\parindent=28pt
(2,0)    20 21 22 23 24 25 26 27 28 29

\parindent=14pt
(3,0)    30 31 32 33 34 35 36 37 38 39

\parindent=7pt
string     /temperature/description  attr   = 

\parindent=0pt
\texttt{"}Global array written from 'size' processes\texttt{"}

The examples/C/global-array/adios\_read\_global.c program shows how to use the 
generic read API to read in the global array from arbitrary number of processes. 
\label{HToc84890303}\label{HToc212016678}\label{HToc212016920}\label{HToc182553450}

\section{Writing Time-Index into a Variable}

The time-index allows the user to define a variable with an unlimited dimension, 
along which the variable can grow in time. Let's suppose the user wants to write 
out temperature after a certain number of iterations. First, we add the ``time-index'' 
attribute to the adios-group with an arbitrary name, e.g. ``iter''. Next, we find 
the (global) variable temperature in the adios-group and add ``iter'' as an extra 
dimension for it; the record number for that variable will be stored every time 
it gets written out. Note that we do not need to change the dimensions and offsets 
in the global bounds, only the individual variable. Also note, that the time dimension 
must be the slowest changing dimension, i.e. in C, the first one and in Fortran, 
it must be the last one.

/* config.xml*/

\texttt{<}adios-config host-language=\texttt{"}C\texttt{"}\texttt{>}

\parindent=14pt
\texttt{<}adios-group name=\texttt{"}temperature\texttt{"} coordination-communicator=\texttt{"}comm\texttt{"} 
time-index=''{\color{color02} \textbf{iter''}}\texttt{>}

\parindent=28pt
\texttt{<}var name=\texttt{"}NX\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\texttt{<}var name=\texttt{"}size\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\parindent=57pt
\texttt{<}var name=\texttt{"}key\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\parindent=0pt
{\color{color02} \texttt{<}global-bounds dimensions=\texttt{"}size,NX\texttt{"} 
offsets=\texttt{"}key,0\texttt{"}\texttt{>}}

{\color{color02} \texttt{<}var name=\texttt{"}temperature\texttt{"} gwrite=\texttt{"}t\texttt{"} 
type=\texttt{"}double\texttt{"} }

{\color{color02} dimensions=\texttt{"}}{\color{color02} \textbf{iter}}{\color{color02} ,1,NX\texttt{"}/\texttt{>} 
   }{\color{color02} \textbf{(Note, for Fortran, ``iter'' needs to be put in the 
end, i.e., dimension=''NX,1,iter'')}}

\parindent=14pt
{\color{color02} \texttt{<}/global-bounds\texttt{>}}

\parindent=28pt
\texttt{<}attribute name=\texttt{"}description\texttt{"} path=\texttt{"}/temperature\texttt{"} 

\parindent=43pt
value=\texttt{"}Global array written from 'size' processes over several timesteps\texttt{"} 

type=\texttt{"}string\texttt{"}/\texttt{>}

\parindent=57pt
\texttt{<}/adios-group\texttt{>}

\parindent=0pt
\texttt{<}method group=\texttt{"}temperature\texttt{"} method=\texttt{"}MPI\texttt{"}/\texttt{>}

\texttt{<}buffer size-MB=\texttt{"}1\texttt{"} allocate-time=\texttt{"}now\texttt{"}/\texttt{>}

\texttt{<}/adios-config\texttt{>}

\label{HToc144350191}

\begin{center}
{\color{color20} \textbf{Figure 32. Config.xml for a global array with time}}

{\color{color20} \textbf{(examples/C/global-array-time/adios\_globaltime.xml)}}
\end{center}

\baselineskip=13pt
The examples/C/global-array-time/adios\_globaltime.c is similar to the previous 
example adios\_global.c code. The only difference is that it has an iteration loop 
where each process writes out the data in each of its 13 iterations.

\$ mpirun -np 4 ./adios\_read\_globaltime

\$ bpls -la adios\_globaltime.bp 

Group temperature:

\parindent=7pt
integer    /NX                       scalar = 10

integer    /size                     scalar = 4

\parindent=14pt
integer    /rank                     scalar = 0

\parindent=7pt
double     /temperature              \{13, 4, 10\} = 100 / 1339 / 719.5 / 374.344 
 \{MIN / MAX / AVG / STD\_DEV\}

string     /temperature/description  attr   = \texttt{"}Global array written from 
'size' processes over several timesteps\texttt{"}\label{HToc84890304}\label{HToc212016679}\label{HToc212016921}

\parindent=0pt
A slice of two timesteps (6\textsuperscript{th} and 7\textsuperscript{th}), dumped 
with bpls:

\$ bpls adios\_globaltime.bp -s \texttt{"}5,0,0\texttt{"} -c \texttt{"}2,-1,-1\texttt{"} 
-n 10 -d temperature

\parindent=7pt
double     /temperature  \{13, 4, 10\}

\parindent=14pt
slice (5:6, 0:3, 0:9)

\parindent=0pt
(5,0,0)    600 601 602 603 604 605 606 607 608 609

\parindent=14pt
(5,1,0)    610 611 612 613 614 615 616 617 618 619

(5,2,0)    620 621 622 623 624 625 626 627 628 629

\parindent=28pt
(5,3,0)    630 631 632 633 634 635 636 637 638 639

\parindent=14pt
(6,0,0)    700 701 702 703 704 705 706 707 708 709

(6,1,0)    710 711 712 713 714 715 716 717 718 719

\parindent=28pt
(6,2,0)    720 721 722 723 724 725 726 727 728 729

\parindent=14pt
(6,3,0)    730 731 732 733 734 735 736 737 738 739 \label{HToc182553451}

\section{Reading statistics}

\parindent=0pt
In ADIOS, statistics like minimum, maximum, average and standard deviation can 
be aggregated inexpensively. This section shows how these statistics can be accessed 
from the BP file. The examples/C/stat/stat\_write.c is similar to the previous 
example adios\_globaltime.c. It writes an additional variable ``complex'' of type 
adios\_double\_complex along with ``temperature.''  It also has histogram enabled 
for the variable ``temperature.''  Comparing it with the XML in the previous example, 
stat.xml has the following additions:

/* stat.xml*/

\texttt{<}?xml version=\texttt{"}1.0\texttt{"}?\texttt{>}

\texttt{<}adios-config host-language=\texttt{"}C\texttt{"}\texttt{>}

\texttt{<}adios-group name=\texttt{"}temperature\texttt{"} coordination-communicator=\texttt{"}comm\texttt{"} 

\leftskip=36pt
\parindent=36pt
time-index=\texttt{"}iter\texttt{"}\texttt{>}

\leftskip=0pt
\parindent=0pt
\texttt{<}var name=\texttt{"}NX\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\texttt{<}var name=\texttt{"}rank\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\texttt{<}var name=\texttt{"}size\texttt{"} type=\texttt{"}integer\texttt{"}/\texttt{>}

\texttt{<}global-bounds dimensions=\texttt{"}size,NX\texttt{"} offsets=\texttt{"}rank,0\texttt{"}\texttt{>}

\texttt{<}var name=\texttt{"}temperature\texttt{"} gwrite=\texttt{"}t\texttt{"} 
type=\texttt{"}double\texttt{"}

dimensions=\texttt{"}iter,1,NX\texttt{"}/\texttt{>}

\parindent=36pt
{\color{color02} \texttt{<}}{\color{color02} \textbf{var}}{\color{color02}  name=\texttt{"}complex\texttt{"} 
gwrite=\texttt{"}c\texttt{"} }{\color{color02} \textbf{type=\texttt{"}double complex\texttt{"}}}

\parindent=0pt
{\color{color02} dimensions=\texttt{"}iter,1,NX\texttt{"}/\texttt{>}}

\texttt{<}/global-bounds\texttt{>}

\parindent=36pt
\texttt{<}/adios-group\texttt{>}

\parindent=0pt
\texttt{<}method group=\texttt{"}temperature\texttt{"} method=\texttt{"}MPI\texttt{"}/\texttt{>}

\texttt{<}buffer size-MB=\texttt{"}5\texttt{"} allocate-time=\texttt{"}now\texttt{"}/\texttt{>}

{\color{color02} \texttt{<}}{\color{color02} \textbf{analysis}}{\color{color02}  
adios-group=\texttt{"}temperature\texttt{"} var=\texttt{"}temperature\texttt{"}}

{\color{color02} break-points=\texttt{"}0, 100, 1000, 10000\texttt{"} /\texttt{>}}

\texttt{<}/adios-config\texttt{>}

\label{HToc144350192}

\begin{center}
{\color{color20} \textbf{Figure 33. Config.xml for creating histogram for an array 
variable}}

{\color{color20} \textbf{(examples/C/stat/stat.xml)}}
\end{center}

To include histogram calculation, only the XML file needs to be updated, and no 
change is required in the C code. The examples/C/stat/gwrite\_stat.ch requires 
an additional {\color{color02} 8 * (2) * NX} to be added to adios\_groupsize and 
an adios\_write (adios\_handle, \texttt{"}complex\texttt{"}, \&c) to handle the 
complex numbers.

\$ mpirun -np 2 ./stat\_write

[1]: adios\_stat.bp written successfully

[0]: adios\_stat.bp written successfully

The examples/C/stat/stat\_read.c shows how to read back the statistics from the 
bp file. First, the statistics need to be populated into an ADIOS\_VARINFO object. 
This is done with the following set of commands.

ADIOS\_FILE * f = adios\_fopen (\texttt{"}adios\_stat.bp\texttt{"}, comm);

ADIOS\_GROUP * g = adios\_gopen (f, \texttt{"}temperature\texttt{"});

ADIOS\_VARINFO * v = adios\_inq\_var (g, \texttt{"}temperature\texttt{"});

The object `v' now contains all the statistical information for the variable ``temperature.'' 
To access the histogram for temperature, we need to access the ADIOS\_HIST data 
structure inside the ADIOS\_VARINFO object. The code below prints the break points 
and the interval frequencies for the global histogram. For `n' break points there 
are `n + 1' intervals.

/* Break points */

for (j = 0; j \texttt{<} v-\texttt{>}hist-\texttt{>}num\_breaks; j++)

\parindent=28pt
printf (\texttt{"}\%lf \texttt{"}, v-\texttt{>}hist-\texttt{>}breaks[j]);

\parindent=0pt
/* Frequencies */

for (j = 0; j \texttt{<}= v-\texttt{>}hist-\texttt{>}num\_breaks; j++)

\parindent=28pt
printf (\texttt{"}\%d\textbackslash{}t\texttt{"}, v-\texttt{>}hist-\texttt{>}gfrequencies[j]);

\parindent=0pt
adios\_free\_varinfo(v);

To access the statistics related to the variable ``complex,'' we need:

v = adios\_inq\_var (g, \texttt{"}complex\texttt{"});

The code below describes how to print the minimum values of the magnitude, real 
and imaginary part of complex data at each timestep. For complex variables alone, 
all statistics need to be typecasted into a double format.

double ** Cmin = (double **) v-\texttt{>}mins;

printf (\texttt{"}\textbackslash{}nMagnitude  Real  Imaginary\textbackslash{}n\texttt{"});

for (j = 0; v-\texttt{>}ndim \texttt{>}= 0 \&\&  (j \texttt{<} v-\texttt{>}dims[0]); 
j ++) 

printf (\texttt{"}\%lf \%lf \%lf\textbackslash{}n\texttt{"}, 

Cmin[j][0], Cmin[j][1], Cmin[j][2]);

adios\_free\_varinfo(v);\label{HToc82064268}\label{HToc82067516}\label{HToc84890309}\label{HToc212016684}\label{HToc212016926}\label{HToc82067538}\label{HToc182553452}
